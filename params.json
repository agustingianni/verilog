{"name":"Verilogin'","tagline":"This site is mainly used as a log of my learning process of verilog.","body":"# Verilogin'\r\nCompendium of all my notes taken while learning Verilog.\r\n\r\n## Basics\r\n\r\n### Sized numbers\r\nThe size of the numbers are specified.\r\n\r\n    <bit_size> '<base> <number>\r\n    8'b11111111\r\n    8'o377\r\n    8'd255\r\n    8'hff\r\n\r\n### Unsized numbers\r\nBy default these are 32 bit at least, depends on the implementation.\r\n\r\n    123\r\n    'o123\r\n    'h123\r\n\r\n### Special \"numbers\"\r\nVerilog has two weird \"numbers\" that are very useful to represent unknown things, they are `x` and `z`.\r\nThe character `x` in a number represents an unknown value. They are useful in a number of situations but where I think they excel is at comparisons like inside the `case` statements.\r\n\r\n    8'b1111xxxx \r\n\r\nThere is also the `_` number. This is used to indicate that certain parts of a number are not used.\r\n\r\n    8'b1111__xx\r\n\r\n### Registers & wires\r\nWires are like inmutable registers, they have a value but they don't \"hold\" it.\r\nRegisters maintain status and are, as far as I know, the equivalent of flip-flips.\r\n\r\n    reg some_reg;\r\n\r\nSince we did not assign a value for the single bit register `some_reg` the value it holds is `1'bx`.\r\n\r\n### Vectors\r\nBoth wires and registers can be made to be vectors by specifying a vector size. It should be noted that vectors are not array and specifying the size range creates a register or a wire of a certain bit length `n`.\r\n\r\n    reg [7:0] some_reg;\r\n\r\nNow `some_reg` will be a register vector of size 8.\r\n\r\n### Integers\r\nThe type of registers is `unsigned` so they are not that convenient for some operations that are inherently signed. In order to overcome this fact we can use an `integer` that is a signed 32 bit integer (in most of the cases).\r\n\r\n    integer some_integer;\r\n\r\n### Arrays\r\nArrays are also available in Verilog and are used as follows:\r\n\r\n    integer int_array[0:7]; // Array of 8 integer values.\r\n    reg reg_array[0:15];    // Array of 16 register values.\r\n\r\n### Memories\r\nThe way to define a memory range in Verilog seems to be using an array of registers of a given size.\r\n\r\n    reg [7:0]  byte_aligned_memory[0:1023];  // BYTE addressable memory of 1 kilo byte.\r\n    reg [31:0] dword_aligned_memory[0:1023]; // DWORD addressable memory of 4 kilo byte.\r\n\r\n### Parameters\r\nParameters are like constants in C/C++. They can be used as constants inside your designs.\r\n\r\n    parameter MEM_SIZE 1024;\r\n    reg [7:0] byte_mem[0:MEM_SIZE-1];\r\n\r\n## Useful things\r\n\r\n### $display\r\nDisplay is very similar to `printf` and is used for the exact same reason, to print things to the terminal. This is obviously non synthesizable but it will be useful while using the simulator.\r\n\r\n    $display(\"Hello %d\", 1234); // Prints 'Hello 1234'.\r\n\r\n### $monitor\r\nSimilar to display but you only need to call it once and it will make the simulator display whatever you need whenever the thing being monitored changes. It shares the same syntax with `$display` so it is very easy to use. Again this is not synthesizable and can only be used while simulating your designs.\r\n\r\n    $monitor(\"Clock value clk=%d variable x1 value=%h\", clk, x1); // Will print the message each clock tick.\r\n\r\nThere can only be one active monitor routine so if you need a different one after enabling one you need to use `$monitoroff` and `$monitoron` to stop / start the last monitor.\r\n\r\n### $stop\r\nThis stops the simulation and leaves the simulation in a halted state where you can inspect the stopped state.\r\n\r\n    $stop;\r\n\r\n### $finish\r\nSame as stop but it aborts the simulation and terminates it, not allowing you to introspect into your design.\r\n\r\n    $finish;\r\n\r\n### Macros\r\nEquivalent to C/C++ macros.\r\n\r\n    `define REG8 reg [7:0]\r\n\r\nThe preprocessor will replace each instance of `REG8` with reg [7:0].\r\n\r\n### Including other designs.\r\nIn order to use other verilog designs you can use the include directive.\r\n\r\n    `include design_b.v\r\n\r\n## Modules\r\n\r\n### Purpose\r\nA module is a container of a functional piece of your design. Modules can be reuses and are akin to procedures in regular programming languages. They have input and output variables named ports. Ports are the elements that allow the caller to interact with the module.\r\n\r\nThe declaration is very similar to old style C code.\r\n\r\n    module module_name(arg1, arg2, ..., argn);\r\n\r\n    // Set the direction of the ports.\r\n    input arg1;\r\n    output arg2;\r\n    ...\r\n    inout argn;\r\n\r\n    // Set the 'type' of the ports.\r\n    reg arg1;\r\n    wire arg2;\r\n    ...\r\n    reg argn;\r\n\r\n    // List of statements that work with the ports.\r\n    statement_1;\r\n    statement_2;\r\n    ...\r\n    statement_n;\r\n\r\n    endmodule // End of module 'module_name'.\r\n\r\n## Dataflow modeling\r\n\r\n### Continuous assignment\r\nContinuous assignments are always active, that means that whenever there is a change in one of the elements on the right-hand-side of the assignment expression, the assignment will be performed again.\r\n\r\nThere are two ways to do a continuous assignment operation, the explicit way (using `assign`) and the implicit way.\r\n\r\n    assign out = in1 & in2;  // Explicit continuous assignment.\r\n    wire out = in1 & in2;    // Implicit continuous assignment.\r\n\r\nIt appears that the most important thing about this topic is the fact that the variable assigned gets 'updated' whenever there is a change in the right-hand-side of the assignment operation.\r\n\r\nAnother interesting characteristic of assignments is that they can delay the assign operation a certain amount of time.\r\n\r\n    assign #5 out = in1 & in2;\r\n    wire #5 out = in1 & in2;\r\n\r\nThe previous two line codes are equivalent and they postpone the assignment of variable `out` five time units after any change is detected in either `in1` or `in2`.\r\n\r\n### Weird operators\r\nVerilog has all the usual operators that you would find in C/C++ but the it adds some more that are relevant to hardware design.\r\n\r\n* Case equality (`===`) is used when the compared bits can include `x` and `z` bits.\r\n* Case inequality (`!==`) is used in the same cases as case equality.\r\n* Bitwise nxor (`~^`).\r\n* Concatenation (`{}`) is used to concatenate bits for instance: `{2'b11, 2'b00} === 4'b1100`.\r\n* Replication (`{{}}`) is used to replicate an expression for instance: `{ 4{1'b1 } } === 4'b1111`.\r\n\r\n## Behavioral modeling\r\n\r\nThe behavioral modeling is the modeling of digital designs that is closer to a regular programming language. All the behavioral modeling is done inside `always` or `initial` blocks.\r\n\r\n### Initial blocks\r\n\r\nThese kinds of blocks execute at time 0 only one time during a simulation. Usually are used to initialize all the elements of your design. If there are multiple `initial` blocks, they will be executed in parallel at the same time.\r\n\r\n    initial\r\n    begin\r\n    some_reg = 1'b0;\r\n    clk = 1'b0;\r\n    $finish; // halt the simulation.\r\n    end\r\n\r\nAs evidenced in the previous example, at least one of the `initial` blocks needs to finish with a `$finish` or `$stop` statement in order to avoid running forever.\r\n\r\n\r\n### Always blocks\r\nAlways blocks are similar to initial blocks but they keep executing forever.\r\n\r\n### Procedural assignment\r\nUsed to update the value of a `reg`, `integer`, `real` or `time` variable. The main difference with the continuous assignment counterpart is that the value of the assigned value will not change unless there is another procedural assignment on the same variable.\r\n\r\nThere are two kinds of procedural assignments, blocking and non blocking. The main difference is, as the name explains, the blocking nature. Blocking assignments 'execute' in the order they are made inside the sequential block.\r\n\r\n    variable_1 = 0;  // blocking assignment.\r\n    variable_2 <= 0; // non blocking assignment.\r\n\r\nThe main idea behind non blocking assignments is to avoid race conditions between concurrent data transfers. I have yet to understand how this works though.\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}