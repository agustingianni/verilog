<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Verilogin&#39; by agustingianni</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Verilogin&#39;</h1>
      <h2 class="project-tagline">This site is mainly used as a log of my learning process of verilog.</h2>
      <a href="https://github.com/agustingianni/verilog" class="btn">View on GitHub</a>
      <a href="https://github.com/agustingianni/verilog/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/agustingianni/verilog/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="verilogin" class="anchor" href="#verilogin" aria-hidden="true"><span class="octicon octicon-link"></span></a>Verilogin'</h1>

<p>Compendium of all my notes taken while learning Verilog.</p>

<h2>
<a id="basics" class="anchor" href="#basics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Basics</h2>

<h3>
<a id="sized-numbers" class="anchor" href="#sized-numbers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sized numbers</h3>

<p>The size of the numbers are specified.</p>

<pre><code>&lt;bit_size&gt; '&lt;base&gt; &lt;number&gt;
8'b11111111
8'o377
8'd255
8'hff
</code></pre>

<h3>
<a id="unsized-numbers" class="anchor" href="#unsized-numbers" aria-hidden="true"><span class="octicon octicon-link"></span></a> Unsized numbers</h3>

<p>By default these are 32 bit at least, depends on the implementation.</p>

<pre><code>123
'o123
'h123
</code></pre>

<h3>
<a id="special-numbers" class="anchor" href="#special-numbers" aria-hidden="true"><span class="octicon octicon-link"></span></a> Special "numbers"</h3>

<p>Verilog has two weird "numbers" that are very useful to represent unknown things, they are <code>x</code> and <code>z</code>.
The character <code>x</code> in a number represents an unknown value. They are useful in a number of situations but where I think they excel is at comparisons like inside the <code>case</code> statements.</p>

<pre><code>8'b1111xxxx 
</code></pre>

<p>There is also the <code>_</code> number. This is used to indicate that certain parts of a number are not used.</p>

<pre><code>8'b1111__xx
</code></pre>

<h3>
<a id="registers--wires" class="anchor" href="#registers--wires" aria-hidden="true"><span class="octicon octicon-link"></span></a>Registers &amp; wires</h3>

<p>Wires are like inmutable registers, they have a value but they don't "hold" it.
Registers maintain status and are, as far as I know, the equivalent of flip-flips.</p>

<pre><code>reg some_reg;
</code></pre>

<p>Since we did not assign a value for the single bit register <code>some_reg</code> the value it holds is <code>1'bx</code>.</p>

<h3>
<a id="vectors" class="anchor" href="#vectors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vectors</h3>

<p>Both wires and registers can be made to be vectors by specifying a vector size. It should be noted that vectors are not array and specifying the size range creates a register or a wire of a certain bit length <code>n</code>.</p>

<pre><code>reg [7:0] some_reg;
</code></pre>

<p>Now <code>some_reg</code> will be a register vector of size 8.</p>

<h3>
<a id="integers" class="anchor" href="#integers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Integers</h3>

<p>The type of registers is <code>unsigned</code> so they are not that convenient for some operations that are inherently signed. In order to overcome this fact we can use an <code>integer</code> that is a signed 32 bit integer (in most of the cases).</p>

<pre><code>integer some_integer;
</code></pre>

<h3>
<a id="arrays" class="anchor" href="#arrays" aria-hidden="true"><span class="octicon octicon-link"></span></a>Arrays</h3>

<p>Arrays are also available in Verilog and are used as follows:</p>

<pre><code>integer int_array[0:7]; // Array of 8 integer values.
reg reg_array[0:15];    // Array of 16 register values.
</code></pre>

<h3>
<a id="memories" class="anchor" href="#memories" aria-hidden="true"><span class="octicon octicon-link"></span></a>Memories</h3>

<p>The way to define a memory range in Verilog seems to be using an array of registers of a given size.</p>

<pre><code>reg [7:0]  byte_aligned_memory[0:1023];  // BYTE addressable memory of 1 kilo byte.
reg [31:0] dword_aligned_memory[0:1023]; // DWORD addressable memory of 4 kilo byte.
</code></pre>

<h3>
<a id="parameters" class="anchor" href="#parameters" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parameters</h3>

<p>Parameters are like constants in C/C++. They can be used as constants inside your designs.</p>

<pre><code>parameter MEM_SIZE 1024;
reg [7:0] byte_mem[0:MEM_SIZE-1];
</code></pre>

<h2>
<a id="useful-things" class="anchor" href="#useful-things" aria-hidden="true"><span class="octicon octicon-link"></span></a>Useful things</h2>

<h3>
<a id="display" class="anchor" href="#display" aria-hidden="true"><span class="octicon octicon-link"></span></a>$display</h3>

<p>Display is very similar to <code>printf</code> and is used for the exact same reason, to print things to the terminal. This is obviously non synthesizable but it will be useful while using the simulator.</p>

<pre><code>$display("Hello %d", 1234); // Prints 'Hello 1234'.
</code></pre>

<h3>
<a id="monitor" class="anchor" href="#monitor" aria-hidden="true"><span class="octicon octicon-link"></span></a>$monitor</h3>

<p>Similar to display but you only need to call it once and it will make the simulator display whatever you need whenever the thing being monitored changes. It shares the same syntax with <code>$display</code> so it is very easy to use. Again this is not synthesizable and can only be used while simulating your designs.</p>

<pre><code>$monitor("Clock value clk=%d variable x1 value=%h", clk, x1); // Will print the message each clock tick.
</code></pre>

<p>There can only be one active monitor routine so if you need a different one after enabling one you need to use <code>$monitoroff</code> and <code>$monitoron</code> to stop / start the last monitor.</p>

<h3>
<a id="stop" class="anchor" href="#stop" aria-hidden="true"><span class="octicon octicon-link"></span></a>$stop</h3>

<p>This stops the simulation and leaves the simulation in a halted state where you can inspect the stopped state.</p>

<pre><code>$stop;
</code></pre>

<h3>
<a id="finish" class="anchor" href="#finish" aria-hidden="true"><span class="octicon octicon-link"></span></a>$finish</h3>

<p>Same as stop but it aborts the simulation and terminates it, not allowing you to introspect into your design.</p>

<pre><code>$finish;
</code></pre>

<h3>
<a id="macros" class="anchor" href="#macros" aria-hidden="true"><span class="octicon octicon-link"></span></a>Macros</h3>

<p>Equivalent to C/C++ macros.</p>

<pre><code>`define REG8 reg [7:0]
</code></pre>

<p>The preprocessor will replace each instance of <code>REG8</code> with reg [7:0].</p>

<h3>
<a id="including-other-designs" class="anchor" href="#including-other-designs" aria-hidden="true"><span class="octicon octicon-link"></span></a> Including other designs.</h3>

<p>In order to use other verilog designs you can use the include directive.</p>

<pre><code>`include design_b.v
</code></pre>

<h2>
<a id="modules" class="anchor" href="#modules" aria-hidden="true"><span class="octicon octicon-link"></span></a>Modules</h2>

<h3>
<a id="purpose" class="anchor" href="#purpose" aria-hidden="true"><span class="octicon octicon-link"></span></a>Purpose</h3>

<p>A module is a container of a functional piece of your design. Modules can be reuses and are akin to procedures in regular programming languages. They have input and output variables named ports. Ports are the elements that allow the caller to interact with the module.</p>

<p>The declaration is very similar to old style C code.</p>

<pre><code>module module_name(arg1, arg2, ..., argn);

// Set the direction of the ports.
input arg1;
output arg2;
...
inout argn;

// Set the 'type' of the ports.
reg arg1;
wire arg2;
...
reg argn;

// List of statements that work with the ports.
statement_1;
statement_2;
...
statement_n;

endmodule // End of module 'module_name'.
</code></pre>

<h2>
<a id="dataflow-modeling" class="anchor" href="#dataflow-modeling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dataflow modeling</h2>

<h3>
<a id="continuous-assignment" class="anchor" href="#continuous-assignment" aria-hidden="true"><span class="octicon octicon-link"></span></a>Continuous assignment</h3>

<p>Continuous assignments are always active, that means that whenever there is a change in one of the elements on the right-hand-side of the assignment expression, the assignment will be performed again.</p>

<p>There are two ways to do a continuous assignment operation, the explicit way (using <code>assign</code>) and the implicit way.</p>

<pre><code>assign out = in1 &amp; in2;  // Explicit continuous assignment.
wire out = in1 &amp; in2;    // Implicit continuous assignment.
</code></pre>

<p>It appears that the most important thing about this topic is the fact that the variable assigned gets 'updated' whenever there is a change in the right-hand-side of the assignment operation.</p>

<p>Another interesting characteristic of assignments is that they can delay the assign operation a certain amount of time.</p>

<pre><code>assign #5 out = in1 &amp; in2;
wire #5 out = in1 &amp; in2;
</code></pre>

<p>The previous two line codes are equivalent and they postpone the assignment of variable <code>out</code> five time units after any change is detected in either <code>in1</code> or <code>in2</code>.</p>

<h3>
<a id="weird-operators" class="anchor" href="#weird-operators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Weird operators</h3>

<p>Verilog has all the usual operators that you would find in C/C++ but the it adds some more that are relevant to hardware design.</p>

<ul>
<li>Case equality (<code>===</code>) is used when the compared bits can include <code>x</code> and <code>z</code> bits.</li>
<li>Case inequality (<code>!==</code>) is used in the same cases as case equality.</li>
<li>Bitwise nxor (<code>~^</code>).</li>
<li>Concatenation (<code>{}</code>) is used to concatenate bits for instance: <code>{2'b11, 2'b00} === 4'b1100</code>.</li>
<li>Replication (<code>{{}}</code>) is used to replicate an expression for instance: <code>{ 4{1'b1 } } === 4'b1111</code>.</li>
</ul>

<h2>
<a id="behavioral-modeling" class="anchor" href="#behavioral-modeling" aria-hidden="true"><span class="octicon octicon-link"></span></a> Behavioral modeling</h2>

<p>The behavioral modeling is the modeling of digital designs that is closer to a regular programming language. All the behavioral modeling is done inside <code>always</code> or <code>initial</code> blocks.</p>

<h3>
<a id="initial-blocks" class="anchor" href="#initial-blocks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Initial blocks</h3>

<p>These kinds of blocks execute at time 0 only one time during a simulation. Usually are used to initialize all the elements of your design. If there are multiple <code>initial</code> blocks, they will be executed in parallel at the same time.</p>

<pre><code>initial
begin
some_reg = 1'b0;
clk = 1'b0;
$finish; // halt the simulation.
end
</code></pre>

<p>As evidenced in the previous example, at least one of the <code>initial</code> blocks needs to finish with a <code>$finish</code> or <code>$stop</code> statement in order to avoid running forever.</p>

<h3>
<a id="always-blocks" class="anchor" href="#always-blocks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Always blocks</h3>

<p>Always blocks are similar to initial blocks but they keep executing forever.</p>

<h3>
<a id="procedural-assignment" class="anchor" href="#procedural-assignment" aria-hidden="true"><span class="octicon octicon-link"></span></a>Procedural assignment</h3>

<p>Used to update the value of a <code>reg</code>, <code>integer</code>, <code>real</code> or <code>time</code> variable. The main difference with the continuous assignment counterpart is that the value of the assigned value will not change unless there is another procedural assignment on the same variable.</p>

<p>There are two kinds of procedural assignments, blocking and non blocking. The main difference is, as the name explains, the blocking nature. Blocking assignments 'execute' in the order they are made inside the sequential block.</p>

<pre><code>variable_1 = 0;  // blocking assignment.
variable_2 &lt;= 0; // non blocking assignment.
</code></pre>

<p>The main idea behind non blocking assignments is to avoid race conditions between concurrent data transfers. I have yet to understand how this works though.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/agustingianni/verilog">Verilogin&#39;</a> is maintained by <a href="https://github.com/agustingianni">agustingianni</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
